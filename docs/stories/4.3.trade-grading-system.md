# Story 4.3: Implement Trade Grading System

## Status
Draft

## Story
**As a** trader,  
**I want** each of my trades to receive an objective grade,  
**so that** I can quickly assess the quality of my decision-making, not just the outcome.

## Acceptance Criteria

1. The system has a grading algorithm that assigns a score (e.g., A, B, C, F) to each closed trade
2. The grade is calculated based on adherence to risk rules, indicator alignment, and the psychological state tagged
3. The grade is displayed on each trade's record
4. The user can filter trades by their grade on the "Analysis" screen

## Tasks / Subtasks

- [ ] Task 1: Create trade grading algorithm engine (AC: 1, 2)
  - [ ] Define comprehensive grading criteria with weighted scoring
  - [ ] Implement risk management adherence scoring
  - [ ] Add indicator alignment impact on grades
  - [ ] Create mindset state scoring system
  - [ ] Add outcome vs. process quality weighting

- [ ] Task 2: Implement backend grading calculation (AC: 1, 2)
  - [ ] Create trade grading service with algorithm
  - [ ] Add automatic grading on trade closure
  - [ ] Implement grade recalculation when analysis updated
  - [ ] Store grade history for tracking improvements
  - [ ] Add grading explanation and breakdown

- [ ] Task 3: Create grade display components (AC: 3)
  - [ ] Build TradeGrade component with visual representation
  - [ ] Add grade badges with colors and icons
  - [ ] Create grade breakdown tooltip with scoring details
  - [ ] Implement grade trend indicators
  - [ ] Add grade comparison visualization

- [ ] Task 4: Integrate grading into trade displays (AC: 3, 4)
  - [ ] Add grade display to TradeList component
  - [ ] Show grade in trade detail views
  - [ ] Add grade column to analytics screen
  - [ ] Implement grade-based sorting functionality
  - [ ] Create grade filter controls

- [ ] Task 5: Create grade analytics and insights (AC: 4)
  - [ ] Build grade distribution analysis
  - [ ] Create grade improvement tracking over time
  - [ ] Implement grade correlation with performance
  - [ ] Add grade-based coaching recommendations
  - [ ] Create grade comparison between filter sets

- [ ] Task 6: Write comprehensive tests (AC: 1, 2, 3, 4)
  - [ ] Unit tests for grading algorithm accuracy
  - [ ] Backend integration tests for grade calculation
  - [ ] Frontend component tests for TradeGrade display
  - [ ] E2E test for complete grading workflow
  - [ ] Test grade filtering and analytics functionality

## Dev Notes

### Previous Story Context
Story 4.2 established performance statistics calculation. This story implements an objective trade grading system that evaluates decision-making quality independent of outcomes, completing the analytics framework.

### Trade Grading Algorithm
[Source: docs/architecture.md#critical-implementation-requirements]

**Comprehensive Grading System:**
```typescript
interface TradeGrade {
  overall: GradeLevel;
  breakdown: {
    riskManagement: GradeComponent;
    methodAlignment: GradeComponent;
    mindsetQuality: GradeComponent;
    execution: GradeComponent;
  };
  score: number; // 0-100 scale
  explanation: string[];
  recommendations: string[];
}

enum GradeLevel {
  A_PLUS = 'A+',
  A = 'A',
  A_MINUS = 'A-',
  B_PLUS = 'B+',
  B = 'B',
  B_MINUS = 'B-',
  C_PLUS = 'C+',
  C = 'C',
  C_MINUS = 'C-',
  D = 'D',
  F = 'F'
}

interface GradeComponent {
  score: number; // 0-100
  weight: number; // Contribution to overall grade
  factors: string[];
  improvements: string[];
}

const calculateTradeGrade = (
  trade: TradeWithFullAnalysis
): TradeGrade => {
  // Risk Management Score (35% weight)
  const riskManagement = calculateRiskManagementScore(trade);
  
  // Method Alignment Score (30% weight)
  const methodAlignment = calculateMethodAlignmentScore(trade);
  
  // Mindset Quality Score (25% weight)
  const mindsetQuality = calculateMindsetQualityScore(trade);
  
  // Execution Score (10% weight)
  const execution = calculateExecutionScore(trade);
  
  // Calculate weighted overall score
  const overallScore = new Decimal(riskManagement.score)
    .times(0.35)
    .plus(new Decimal(methodAlignment.score).times(0.30))
    .plus(new Decimal(mindsetQuality.score).times(0.25))
    .plus(new Decimal(execution.score).times(0.10))
    .toNumber();
  
  return {
    overall: scoreToGradeLevel(overallScore),
    breakdown: {
      riskManagement,
      methodAlignment,
      mindsetQuality,
      execution
    },
    score: overallScore,
    explanation: generateGradeExplanation(trade, overallScore),
    recommendations: generateImprovementRecommendations(trade)
  };
};
```

### Grading Component Calculations
[Source: docs/architecture.md#critical-implementation-requirements]

**Risk Management Scoring:**
```typescript
const calculateRiskManagementScore = (trade: TradeWithFullAnalysis): GradeComponent => {
  let score = 100;
  const factors: string[] = [];
  const improvements: string[] = [];
  
  // Individual trade risk adherence (50% of risk score)
  const riskPercentage = new Decimal(trade.riskAmount)
    .dividedBy(trade.user.totalEquity)
    .times(100)
    .toNumber();
  
  if (riskPercentage <= 1.5) {
    factors.push('Excellent risk sizing (≤1.5%)');
  } else if (riskPercentage <= 2.0) {
    factors.push('Good risk sizing (≤2%)');
    score -= 10;
  } else if (riskPercentage <= 3.0) {
    factors.push('Acceptable risk sizing (≤3%)');
    score -= 25;
    improvements.push('Reduce position size to stay within 2% rule');
  } else {
    factors.push('Poor risk sizing (>3%)');
    score -= 50;
    improvements.push('CRITICAL: Reduce position size significantly');
  }
  
  // Stop-loss usage (25% of risk score)
  if (trade.stopLoss) {
    factors.push('Proper stop-loss placement');
  } else {
    score -= 25;
    improvements.push('Always set stop-loss before entering trade');
  }
  
  // Position sizing logic (25% of risk score)
  const optimalSize = calculateOptimalPositionSize(
    trade.entryPrice,
    trade.stopLoss,
    trade.user.totalEquity,
    0.02 // 2% risk target
  );
  
  const sizingAccuracy = Math.abs(trade.positionSize - optimalSize) / optimalSize;
  if (sizingAccuracy <= 0.1) {
    factors.push('Optimal position sizing');
  } else if (sizingAccuracy <= 0.25) {
    factors.push('Good position sizing');
    score -= 5;
  } else {
    score -= 15;
    improvements.push('Improve position sizing calculation');
  }
  
  return {
    score: Math.max(0, score),
    weight: 0.35,
    factors,
    improvements
  };
};
```

**Method Alignment Scoring:**
```typescript
const calculateMethodAlignmentScore = (trade: TradeWithFullAnalysis): GradeComponent => {
  let score = 100;
  const factors: string[] = [];
  const improvements: string[] = [];
  
  if (!trade.alignmentAnalysis) {
    return {
      score: 50,
      weight: 0.30,
      factors: ['No method analysis provided'],
      improvements: ['Complete method analysis for all timeframes']
    };
  }
  
  // Overall alignment score impact (60% of method score)
  const alignmentScore = trade.alignmentAnalysis.overallScore;
  const alignmentPoints = Math.round((alignmentScore + 1) * 30); // Convert -1/1 to 0-60
  score = 40 + alignmentPoints; // Base 40 points + alignment bonus
  
  switch (trade.alignmentAnalysis.alignmentLevel) {
    case 'STRONG_ALIGNMENT':
      factors.push('Excellent signal alignment across timeframes');
      break;
    case 'WEAK_ALIGNMENT':
      factors.push('Good signal alignment');
      break;
    case 'NEUTRAL':
      factors.push('Neutral signal alignment');
      improvements.push('Seek stronger confluence between timeframes');
      break;
    case 'WEAK_CONFLICT':
      factors.push('Some signal conflicts detected');
      improvements.push('Review conflicting signals before entry');
      break;
    case 'STRONG_CONFLICT':
      factors.push('Major signal conflicts detected');
      improvements.push('CRITICAL: Avoid trades with conflicting signals');
      break;
  }
  
  // Timeframe completeness (40% of method score)
  const completedTimeframes = trade.methodAnalysis.length;
  if (completedTimeframes === 3) {
    factors.push('Complete three-timeframe analysis');
  } else if (completedTimeframes === 2) {
    score -= 10;
    improvements.push('Complete analysis for all three timeframes');
  } else {
    score -= 20;
    improvements.push('Perform multi-timeframe analysis before trading');
  }
  
  return {
    score: Math.max(0, score),
    weight: 0.30,
    factors,
    improvements
  };
};
```

**Mindset Quality Scoring:**
```typescript
const calculateMindsetQualityScore = (trade: TradeWithFullAnalysis): GradeComponent => {
  let score = 100;
  const factors: string[] = [];
  const improvements: string[] = [];
  
  if (!trade.mindsetTags || trade.mindsetTags.length === 0) {
    return {
      score: 50,
      weight: 0.25,
      factors: ['No mindset assessment provided'],
      improvements: ['Track psychological state before trading']
    };
  }
  
  const positiveStates = ['DISCIPLINED', 'PATIENT', 'CONFIDENT', 'FOCUSED', 'CALM', 'ANALYTICAL'];
  const negativeStates = ['ANXIOUS', 'FOMO', 'GREEDY', 'FEARFUL', 'IMPULSIVE', 'REVENGE_TRADING', 'OVERCONFIDENT'];
  
  let positiveCount = 0;
  let negativeCount = 0;
  
  trade.mindsetTags.forEach(tag => {
    if (positiveStates.includes(tag.tag)) {
      positiveCount++;
      factors.push(`Positive mindset: ${tag.tag}`);
    } else if (negativeStates.includes(tag.tag)) {
      negativeCount++;
      factors.push(`Negative mindset: ${tag.tag}`);
      improvements.push(`Address ${tag.tag.toLowerCase()} before trading`);
    }
  });
  
  // Score based on mindset balance
  if (negativeCount === 0 && positiveCount > 0) {
    // Perfect mindset
    factors.push('Excellent psychological state');
  } else if (positiveCount > negativeCount) {
    // More positive than negative
    score -= negativeCount * 10;
    factors.push('Generally positive mindset');
  } else if (negativeCount > positiveCount) {
    // More negative than positive
    score -= negativeCount * 20;
    improvements.push('Work on psychological preparation before trading');
  } else {
    // Equal or mixed
    score -= 25;
    improvements.push('Improve psychological consistency');
  }
  
  return {
    score: Math.max(0, score),
    weight: 0.25,
    factors,
    improvements
  };
};
```

### Grade Display Specifications
[Source: docs/architecture.md#frontend-architecture]

**TradeGrade Component:**
```typescript
interface TradeGradeProps {
  grade: TradeGrade;
  showBreakdown?: boolean;
  compact?: boolean;
  interactive?: boolean;
}

// Visual specifications:
// - Letter grade with color coding
// - Expandable breakdown on hover/click
// - Progress bars for component scores
// - Improvement recommendations display
// - Grade history trend indicator
```

**Grade Color System:**
```typescript
const getGradeColor = (grade: GradeLevel): string => {
  switch (grade) {
    case 'A+':
    case 'A':
      return '#10b981'; // emerald-500 - Excellent
    case 'A-':
    case 'B+':
      return '#22c55e'; // green-500 - Very Good
    case 'B':
    case 'B-':
      return '#84cc16'; // lime-500 - Good
    case 'C+':
    case 'C':
      return '#eab308'; // yellow-500 - Average
    case 'C-':
    case 'D':
      return '#f97316'; // orange-500 - Below Average
    case 'F':
      return '#ef4444'; // red-500 - Poor
    default:
      return '#6b7280'; // gray-500 - Unknown
  }
};
```

### API Specifications
[Source: docs/architecture.md#api-specification]

**Enhanced Trade Model:**
```typescript
interface TradeWithGrade extends TradeWithFullAnalysis {
  grade: TradeGrade;
  gradeHistory: Array<{
    grade: GradeLevel;
    score: number;
    calculatedAt: Date;
    reason: string; // 'TRADE_CLOSE' | 'ANALYSIS_UPDATE' | 'MANUAL_RECALC'
  }>;
}
```

**POST /api/trades/{tradeId}/recalculate-grade**
- Manually triggers grade recalculation
- Updates grade based on current analysis
- Returns updated trade with new grade
- Logs grade change in history

### Grade Calculation Workflow
[Source: docs/architecture.md#critical-implementation-requirements]

**Automatic Grading Triggers:**
```typescript
// Grading occurs automatically when:
// 1. Trade is closed (primary grading event)
// 2. Method analysis is updated/added
// 3. Mindset tags are modified
// 4. Stop-loss is adjusted (impacts risk score)

const shouldRecalculateGrade = (
  updateType: 'CLOSE' | 'ANALYSIS_UPDATE' | 'MINDSET_UPDATE' | 'STOP_ADJUSTMENT'
): boolean => {
  // Always recalculate for closed trades
  if (updateType === 'CLOSE') return true;
  
  // Recalculate when analysis components change
  return ['ANALYSIS_UPDATE', 'MINDSET_UPDATE', 'STOP_ADJUSTMENT'].includes(updateType);
};
```

### Advanced Grading Features
[Source: docs/architecture.md#data-models]

**Grade Analytics:**
```typescript
interface GradeAnalytics {
  gradeDistribution: Record<GradeLevel, number>;
  averageGrade: number;
  gradeImprovement: {
    trend: 'IMPROVING' | 'DECLINING' | 'STABLE';
    changeRate: number;
    recentAverage: number;
    historicalAverage: number;
  };
  correlations: {
    gradeVsOutcome: number;
    gradeVsRisk: number;
    gradeVsAlignment: number;
  };
}

const calculateGradeAnalytics = (
  gradesOverTime: Array<{ grade: TradeGrade; date: Date }>
): GradeAnalytics => {
  // Calculate grade distribution
  // Analyze grade improvement trends
  // Correlate grades with outcomes
  // Generate insights and recommendations
};
```

### Grade-based Coaching System
[Source: docs/architecture.md#ui-ux-specification]

**Coaching Recommendations:**
```typescript
const generateCoachingRecommendations = (
  recentGrades: TradeGrade[]
): string[] => {
  const recommendations: string[] = [];
  
  // Analyze grade patterns
  const avgRiskScore = recentGrades.reduce((sum, g) => 
    sum + g.breakdown.riskManagement.score, 0
  ) / recentGrades.length;
  
  if (avgRiskScore < 70) {
    recommendations.push('Focus on improving risk management discipline');
    recommendations.push('Review position sizing calculations before each trade');
  }
  
  const avgAlignmentScore = recentGrades.reduce((sum, g) => 
    sum + g.breakdown.methodAlignment.score, 0
  ) / recentGrades.length;
  
  if (avgAlignmentScore < 70) {
    recommendations.push('Seek stronger signal confluence across timeframes');
    recommendations.push('Avoid trades with conflicting technical indicators');
  }
  
  return recommendations;
};
```

### Frontend Integration
[Source: docs/architecture.md#frontend-architecture]

**Grade Filter Integration:**
```typescript
// In TradeFilters component
interface GradeFilterProps {
  selectedGrades: GradeLevel[];
  onGradeChange: (grades: GradeLevel[]) => void;
}

// Grade filter categories:
const GRADE_CATEGORIES = {
  excellent: ['A+', 'A', 'A-'],
  good: ['B+', 'B', 'B-'],
  average: ['C+', 'C', 'C-'],
  poor: ['D', 'F']
};
```

**GradeAnalyticsWidget Component:**
```typescript
interface GradeAnalyticsWidgetProps {
  gradeAnalytics: GradeAnalytics;
  timeRange: 'week' | 'month' | 'quarter' | 'year';
  onTimeRangeChange: (range: string) => void;
}

// Features:
// - Grade distribution pie chart
// - Grade improvement trend line
// - Current grade average display
// - Coaching recommendations panel
// - Grade vs. outcome correlation
```

### File Locations
- Grade types: `packages/shared/src/types/grading.ts`
- Grading engine: `packages/shared/src/utils/grading.ts`
- Grading API: `apps/api/src/routes/grading.ts`
- TradeGrade component: `apps/web/src/components/TradeGrade.tsx`
- GradeAnalyticsWidget: `apps/web/src/components/GradeAnalyticsWidget.tsx`
- Updated analytics screen: `apps/web/src/pages/AnalyticsScreen.tsx`

### Database Schema Updates
[Source: docs/architecture.md#data-models]

**Grade Storage:**
```prisma
model TradeGrade {
  id           String     @id @default(cuid())
  tradeId      String     @unique
  overall      GradeLevel
  score        Float      // 0-100
  riskScore    Float
  alignmentScore Float
  mindsetScore Float
  executionScore Float
  explanation  Json       // Array of explanation strings
  recommendations Json    // Array of improvement suggestions
  calculatedAt DateTime   @default(now())
  
  trade Trade @relation(fields: [tradeId], references: [id], onDelete: Cascade)
}

model GradeHistory {
  id           String     @id @default(cuid())
  tradeId      String
  grade        GradeLevel
  score        Float
  reason       String     // Why grade was calculated
  calculatedAt DateTime   @default(now())
  
  trade Trade @relation(fields: [tradeId], references: [id], onDelete: Cascade)
}
```

### Performance Impact Considerations
[Source: docs/architecture.md#security-and-performance]

**Grading Performance Optimization:**
- Cache grade calculations for unchanged trades
- Batch grade calculations for multiple trades
- Use database views for complex grade queries
- Implement lazy loading for grade breakdowns
- Optimize grade filtering with indexed queries

### Testing

#### Testing Requirements
[Source: docs/architecture.md#testing-strategy]

**Critical Test Scenarios:**
- Grading algorithm accuracy with various trade profiles
- Grade component weighting and calculation
- Real-time grade updates when analysis changes
- Grade filtering and analytics accuracy
- Edge cases (incomplete analysis, extreme scores)
- Grade history tracking and trends

**Grading Algorithm Test Cases:**
```typescript
// Test excellent trade grade
{
  trade: {
    riskAmount: 150,        // 1.5% risk (excellent)
    userEquity: 10000,
    alignmentAnalysis: {
      alignmentLevel: 'STRONG_ALIGNMENT',
      overallScore: 0.8
    },
    mindsetTags: [
      { tag: 'DISCIPLINED', intensity: 'HIGH' },
      { tag: 'PATIENT', intensity: 'MEDIUM' }
    ],
    realizedPnL: 200        // Winning trade
  },
  expectedGrade: 'A',
  expectedScore: 92,
  expectedFactors: [
    'Excellent risk sizing',
    'Strong signal alignment',
    'Positive mindset state'
  ]
}

// Test poor trade grade
{
  trade: {
    riskAmount: 400,        // 4% risk (poor)
    userEquity: 10000,
    alignmentAnalysis: {
      alignmentLevel: 'STRONG_CONFLICT',
      overallScore: -0.7
    },
    mindsetTags: [
      { tag: 'FOMO', intensity: 'HIGH' },
      { tag: 'IMPULSIVE', intensity: 'HIGH' }
    ],
    realizedPnL: -300       // Losing trade
  },
  expectedGrade: 'F',
  expectedScore: 25,
  expectedImprovements: [
    'CRITICAL: Reduce position size significantly',
    'Avoid trades with conflicting signals',
    'Address emotional state before trading'
  ]
}
```

#### Testing Standards
- Test grading algorithm with diverse trade scenarios
- Verify grade component weighting accuracy
- Test real-time grade updates and caching
- Mock grading API in frontend tests
- E2E test covers complete grading workflow

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| August 15, 2025 | 1.0 | Initial story creation | Sarah, Product Owner |

## Dev Agent Record

### Agent Model Used
_To be filled by development agent_

### Debug Log References
_To be filled by development agent_

### Completion Notes List
_To be filled by development agent_

### File List
_To be filled by development agent_

## QA Results
_To be filled by QA agent_
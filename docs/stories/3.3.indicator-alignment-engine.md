# Story 3.3: Implement Indicator Alignment Engine

## Status
Draft

## Story
**As a** trader,  
**I want** the app to analyze my chosen signals and warn me if they conflict with my trade direction, while promoting trades that show strong alignment,  
**so that** I can improve my trade selection discipline.

## Acceptance Criteria

1. The system contains a basic rules engine that understands if a signal (e.g., "Bullish Divergence") aligns with a trade direction (Long or Short)
2. When saving a trade, the system evaluates the signals from all three timeframes
3. If a signal conflicts with the trade direction, a warning is displayed on the trade record
4. If all signals align perfectly with the trade direction, a positive confirmation or promotion (e.g., a green checkmark) is displayed on the trade record

## Tasks / Subtasks

- [ ] Task 1: Create signal alignment rules engine (AC: 1, 2)
  - [ ] Define signal-direction alignment logic using TypeScript
  - [ ] Create comprehensive rules for all indicator/signal combinations
  - [ ] Implement alignment scoring algorithm with weights
  - [ ] Add timeframe-specific alignment considerations
  - [ ] Create alignment validation service

- [ ] Task 2: Implement backend alignment analysis (AC: 2, 3, 4)
  - [ ] Create POST /api/trades/analyze-alignment endpoint
  - [ ] Add alignment calculation to trade creation workflow
  - [ ] Store alignment scores and warnings with trade records
  - [ ] Implement real-time alignment feedback during form entry
  - [ ] Add alignment-based trade recommendations

- [ ] Task 3: Create alignment indicator components (AC: 3, 4)
  - [ ] Build AlignmentIndicator component with visual feedback
  - [ ] Add alignment warning badges and messages
  - [ ] Create alignment confirmation display with positive feedback
  - [ ] Implement alignment score visualization
  - [ ] Add alignment breakdown by timeframe

- [ ] Task 4: Integrate alignment feedback into trade workflow (AC: 1, 2, 3, 4)
  - [ ] Add real-time alignment analysis to TradeForm
  - [ ] Display alignment warnings before trade submission
  - [ ] Show alignment confirmation for well-aligned trades
  - [ ] Update TradeList to show alignment status
  - [ ] Add alignment-based sorting and filtering

- [ ] Task 5: Create alignment analytics and insights (AC: 1, 4)
  - [ ] Build alignment performance correlation analysis
  - [ ] Create alignment trend tracking over time
  - [ ] Implement alignment-based trade recommendations
  - [ ] Add alignment coaching and educational content
  - [ ] Create alignment improvement suggestions

- [ ] Task 6: Write comprehensive tests (AC: 1, 2, 3, 4)
  - [ ] Unit tests for signal alignment rules engine
  - [ ] Backend integration tests for alignment analysis
  - [ ] Frontend component tests for AlignmentIndicator
  - [ ] E2E test for complete alignment feedback workflow
  - [ ] Test alignment accuracy with various signal combinations

## Dev Notes

### Previous Story Context
Story 3.2 established mindset tagging functionality. This story implements the rules engine that validates technical analysis alignment, completing the "Method" component of the Three M's framework.

### Signal Alignment Rules Engine
[Source: docs/architecture.md#critical-implementation-requirements]

**Alignment Rules Logic:**
```typescript
interface AlignmentRule {
  indicator: IndicatorType;
  signal: SignalType;
  bullishAlignment: number; // -1 to 1 scale
  bearishAlignment: number; // -1 to 1 scale
  weight: number; // Importance weight
}

const ALIGNMENT_RULES: AlignmentRule[] = [
  // MACD Rules
  {
    indicator: 'MACD',
    signal: 'BUY_SIGNAL',
    bullishAlignment: 1.0,
    bearishAlignment: -1.0,
    weight: 0.8
  },
  {
    indicator: 'MACD',
    signal: 'SELL_SIGNAL',
    bullishAlignment: -1.0,
    bearishAlignment: 1.0,
    weight: 0.8
  },
  
  // RSI Rules
  {
    indicator: 'RSI',
    signal: 'OVERSOLD',
    bullishAlignment: 0.7,
    bearishAlignment: -0.3,
    weight: 0.6
  },
  {
    indicator: 'RSI',
    signal: 'OVERBOUGHT',
    bullishAlignment: -0.3,
    bearishAlignment: 0.7,
    weight: 0.6
  },
  
  // Divergence Rules
  {
    indicator: 'ANY',
    signal: 'ANY',
    bullishAlignment: 1.0, // When divergence is BULLISH
    bearishAlignment: -1.0,
    weight: 1.0
  }
];

interface AlignmentAnalysis {
  overallScore: number; // -1 to 1 scale
  alignmentLevel: 'STRONG_CONFLICT' | 'WEAK_CONFLICT' | 'NEUTRAL' | 'WEAK_ALIGNMENT' | 'STRONG_ALIGNMENT';
  warnings: string[];
  confirmations: string[];
  timeframeBreakdown: Array<{
    timeframe: TimeframeType;
    score: number;
    analysis: MethodAnalysis;
    alignment: string;
  }>;
}

const analyzeAlignment = (
  tradeDirection: 'LONG' | 'SHORT',
  methodAnalysis: MethodAnalysis[]
): AlignmentAnalysis => {
  let totalScore = 0;
  let totalWeight = 0;
  const warnings: string[] = [];
  const confirmations: string[] = [];
  const timeframeBreakdown = [];
  
  for (const analysis of methodAnalysis) {
    const rule = ALIGNMENT_RULES.find(r => 
      (r.indicator === analysis.indicator || r.indicator === 'ANY') &&
      (r.signal === analysis.signal || r.signal === 'ANY')
    );
    
    if (!rule) continue;
    
    // Calculate alignment score for this analysis
    const alignmentScore = tradeDirection === 'LONG' ? 
      rule.bullishAlignment : rule.bearishAlignment;
    
    // Apply divergence bonus/penalty
    let divergenceMultiplier = 1;
    if (analysis.divergence === 'BULLISH' && tradeDirection === 'LONG') {
      divergenceMultiplier = 1.2;
    } else if (analysis.divergence === 'BEARISH' && tradeDirection === 'SHORT') {
      divergenceMultiplier = 1.2;
    } else if (analysis.divergence !== 'NONE') {
      divergenceMultiplier = 0.8; // Penalty for misaligned divergence
    }
    
    const finalScore = alignmentScore * divergenceMultiplier;
    const weightedScore = finalScore * rule.weight;
    
    totalScore += weightedScore;
    totalWeight += rule.weight;
    
    // Generate warnings and confirmations
    if (finalScore < -0.5) {
      warnings.push(`${analysis.timeframe}: ${analysis.indicator} ${analysis.signal} conflicts with ${tradeDirection} direction`);
    } else if (finalScore > 0.5) {
      confirmations.push(`${analysis.timeframe}: ${analysis.indicator} ${analysis.signal} supports ${tradeDirection} direction`);
    }
    
    timeframeBreakdown.push({
      timeframe: analysis.timeframe,
      score: finalScore,
      analysis,
      alignment: finalScore > 0.5 ? 'ALIGNED' : finalScore < -0.5 ? 'CONFLICTED' : 'NEUTRAL'
    });
  }
  
  const overallScore = totalWeight > 0 ? totalScore / totalWeight : 0;
  
  const alignmentLevel = overallScore > 0.7 ? 'STRONG_ALIGNMENT' :
                        overallScore > 0.3 ? 'WEAK_ALIGNMENT' :
                        overallScore > -0.3 ? 'NEUTRAL' :
                        overallScore > -0.7 ? 'WEAK_CONFLICT' : 'STRONG_CONFLICT';
  
  return {
    overallScore,
    alignmentLevel,
    warnings,
    confirmations,
    timeframeBreakdown
  };
};
```

### API Specifications
[Source: docs/architecture.md#api-specification]

**POST /api/trades/analyze-alignment**
- Analyzes trade direction against method analysis
- Request body: { direction, methodAnalysis }
- Returns alignment analysis with warnings/confirmations
- Used for real-time feedback during trade entry

**Enhanced Trade Response:**
```typescript
interface TradeWithAlignment extends Trade {
  alignmentAnalysis: AlignmentAnalysis;
  methodAnalysis: MethodAnalysis[];
  mindsetTags: MindsetTag[];
}
```

### Frontend Component Specifications
[Source: docs/architecture.md#frontend-architecture]

**AlignmentIndicator Component:**
```typescript
interface AlignmentIndicatorProps {
  alignmentAnalysis: AlignmentAnalysis;
  showDetails?: boolean;
  compact?: boolean;
}

// Visual specifications:
// - Color-coded alignment level indicator
// - Warning/confirmation messages
// - Expandable timeframe breakdown
// - Alignment score visualization (gauge/bar)
// - Educational tooltips for improvement
```

**AlignmentFeedback Component:**
```typescript
interface AlignmentFeedbackProps {
  alignment: AlignmentAnalysis;
  onIgnoreWarning?: () => void;
  showRecommendations?: boolean;
}

// Features:
// - Real-time feedback during trade entry
// - Warning dialogs for conflicted trades
// - Confirmation badges for aligned trades
// - Suggestions for better alignment
// - Override options with confirmation
```

### Trade Form Integration
[Source: docs/architecture.md#frontend-architecture]

**Real-time Alignment Analysis:**
```typescript
// In TradeForm component
const [alignmentAnalysis, setAlignmentAnalysis] = useState<AlignmentAnalysis | null>(null);

useEffect(() => {
  if (direction && methodAnalysis.length > 0) {
    analyzeTradeAlignment(direction, methodAnalysis)
      .then(setAlignmentAnalysis)
      .catch(console.error);
  }
}, [direction, methodAnalysis]);

// Display alignment feedback below method analysis section
// Show warnings prominently before trade submission
// Provide educational content for conflicted signals
```

### Educational Content Integration
[Source: docs/architecture.md#ui-ux-specification]

**Alignment Education:**
- Tooltips explaining why signals conflict or align
- Links to trading education about signal interpretation
- Historical performance data for alignment patterns
- Suggestions for improving signal selection
- Integration with Dr. Elder's "Method" principles

### File Locations
- Alignment types: `packages/shared/src/types/alignment.ts`
- Alignment rules engine: `packages/shared/src/utils/alignment.ts`
- Alignment API: `apps/api/src/routes/alignment.ts`
- AlignmentIndicator: `apps/web/src/components/AlignmentIndicator.tsx`
- AlignmentFeedback: `apps/web/src/components/AlignmentFeedback.tsx`
- Updated TradeForm: `apps/web/src/components/TradeForm.tsx`

### Performance Considerations
[Source: docs/architecture.md#security-and-performance]

**Optimization Strategy:**
- Cache alignment rules in memory
- Debounce real-time analysis during form entry
- Precompute common alignment patterns
- Use efficient scoring algorithms
- Minimize API calls for alignment feedback

### Testing

#### Testing Requirements
[Source: docs/architecture.md#testing-strategy]

**Critical Test Scenarios:**
- Signal alignment logic for all indicator combinations
- Divergence impact on alignment scoring
- Multi-timeframe alignment analysis
- Real-time feedback performance
- Warning/confirmation message accuracy
- Edge cases with incomplete method analysis

**Alignment Logic Test Cases:**
```typescript
// Test strong bullish alignment
{
  tradeDirection: 'LONG',
  methodAnalysis: [
    {
      timeframe: 'DAILY',
      indicator: 'MACD',
      signal: 'BUY_SIGNAL',
      divergence: 'BULLISH'
    },
    {
      timeframe: 'FOUR_HOUR',
      indicator: 'RSI',
      signal: 'OVERSOLD',
      divergence: 'NONE'
    }
  ],
  expectedLevel: 'STRONG_ALIGNMENT',
  expectedConfirmations: 2,
  expectedWarnings: 0
}

// Test signal conflict
{
  tradeDirection: 'LONG',
  methodAnalysis: [
    {
      timeframe: 'DAILY',
      indicator: 'MACD',
      signal: 'SELL_SIGNAL',
      divergence: 'BEARISH'
    }
  ],
  expectedLevel: 'STRONG_CONFLICT',
  expectedWarnings: 1,
  expectedConfirmations: 0
}
```

#### Testing Standards
- Test all alignment rule combinations
- Verify scoring algorithm accuracy
- Test real-time feedback responsiveness
- Mock alignment API in frontend tests
- E2E test covers complete alignment workflow

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| August 15, 2025 | 1.0 | Initial story creation | Sarah, Product Owner |

## Dev Agent Record

### Agent Model Used
_To be filled by development agent_

### Debug Log References
_To be filled by development agent_

### Completion Notes List
_To be filled by development agent_

### File List
_To be filled by development agent_

## QA Results
_To be filled by QA agent_